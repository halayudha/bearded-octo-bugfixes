/*
 * @(#) LogManager.java 1.0 2006-9-14
 * 
 * Copyright 2006, National University of Singapore. All rights reserved.
 */

package sg.edu.nus.logging;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.XMLFormatter;

import sg.edu.nus.peer.AbstractPeer;
import sg.edu.nus.protocol.Message;
import sg.edu.nus.protocol.MsgType;

/**
 * A simple manager to log <code>Exception</code> message. The default
 * <code>Formatter</code> is <code>XMLFormatter</code>. The DTD file used by the
 * default <code>Formatter</code> is generated by this class.
 * 
 * @author chensu
 * @version 1.0 2009-05-04
 */

public class LogManager {

	/**
	 * The only instance of the log manager
	 */
	private static LogManager instance = null;

	/**
	 * The owner peer of the current log manager
	 */
	private static AbstractPeer owner = null;

	/**
	 * File logger
	 */
	private static Logger logger = null;

	private static void createLogDB() {
		try {
			Connection dbconn = AbstractPeer.bestpeer_db
					.createServerConnection();

			Statement stmt = dbconn.createStatement();

			String sql = "create database if not exists " + LOG_DB;

			stmt.execute(sql);

			stmt.close();

			dbconn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void createLogTable() {
		try {
			Connection dbconn = AbstractPeer.bestpeer_db
					.createDbConnection(LOG_DB);

			Statement stmt = dbconn.createStatement();

			String sql = "create table if not exists LOG_MSG (" //
					+ "time timestamp not null default current_timestamp," //
					+ "head int(11) not null," //
					+ "body varchar(256)," //
					+ "size int(11) not null," // 
					+ "sender varchar(64)," //
					+ "receiver varchar(64), " //
					+ "remark varchar(256)" // 
					+ ")";

			stmt.execute(sql);

			sql = "create table if not exists LOG_QUERY (" //
					+ "time timestamp not null default current_timestamp," //
					+ "qid int," //
					+ "query varchar(256)," //
					+ "duration double" //
					+ ")";

			stmt.execute(sql);

			stmt.close();

			dbconn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static Connection getDBConnection() {
		createLogDB();
		createLogTable();
		try {
			Connection dbconn = AbstractPeer.bestpeer_db
					.createDbConnection(LOG_DB);
			return dbconn;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public static int[] getReport(REPORT_ITEM item, TIME_UNIT unit, int numUnits) {
		int[] rsCnt = null;

		try {
			rsCnt = new int[numUnits];

			if (dbconn == null || dbconn.isClosed())
				dbconn = getDBConnection();

			Statement stmt = dbconn.createStatement();

			for (int i = 1; i < numUnits; i++) {
				String sql = item.getQuerySQL();

				String condition = item.getQueryCondition().replaceAll(
						"#TIME_UNIT#", unit.getName()).replaceAll("#START#",
						(i - 1) + "").replaceAll("#END#", i + "");

				if (sql.indexOf(" WHERE ") != -1)
					sql += " AND " + condition;
				else
					sql += " WHERE " + condition;

				ResultSet rs = stmt.executeQuery(sql);

				rs.next();

				rsCnt[i - 1] = rs.getInt(1);

				if (rs.next()) {
					System.err
							.println("Error! The result contains multiple rows.");
				}
			}

			stmt.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return rsCnt;
	}

	/**
	 * Log an event for a task to be executed
	 * 
	 * @param eventType
	 * @param message
	 * @param dest
	 */
	public static void LogPreEvent(String eventType, String message, String dest) {
		if (logger != null)
			logger.event(message);

		ShowGuiLog(new LogEvent(LogEventType.PRE_EVENT.getValue(), message, ""));
	}

	/**
	 * Log all queries
	 * 
	 * @param qid
	 *            query identifier
	 * @param sqlCommand
	 *            query sql
	 * @param duration
	 *            query processing time (-1 if the start of the query)
	 */
	public static void LogQuery(long qid, String sqlCommand, double duration) {
		try {
			if (dbconn == null || dbconn.isClosed())
				dbconn = getDBConnection();

			Statement stmt = dbconn.createStatement();
			String sql = "";

			sqlCommand = sqlCommand.replace('\'', ' ');
			
			if (duration < 0) {
				sql = "insert into LOG_QUERY (qid, query, time) values (" //
						+ qid + ", '" //
						+ sqlCommand + "', " //
						+ "current_timestamp )";
			} else {
				sql = "update LOG_QUERY set duration = " + duration
						+ " where qid = " + qid;
			}

			stmt.execute(sql);

			stmt.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Log an warning message
	 * 
	 * @param message
	 */
	public static void LogWarning(String message) {
		if (logger != null)
			logger.warn(message);

		ShowGuiLog(new LogEvent(LogEventType.WARNING.getValue(), message, ""));
	}

	/**
	 * Initialize the logger. Only one instance for one peer.
	 * 
	 * @param peer
	 */
	public static void setLogger(AbstractPeer peer) {
		if (instance == null)
			instance = new LogManager(peer);
	}

	/**
	 * show this log event on the gui if needed.
	 */
	private static void ShowGuiLog(LogEvent event) {
		if (owner != null && owner.getMainFrame() != null) {
			owner.getMainFrame().log(event);
		}
	}

	/**
	 * File handler for the log file
	 */
	private FileHandler handler = null;

	/**
	 * Connection to log database
	 */
	private static Connection dbconn = null;

	/**
	 * The directory of the log files
	 */
	private static final String LOG_DIR = "logs";

	/**
	 * The database name of the log
	 */
	private static final String LOG_DB = "LOGDB";

	/**
	 * Generate dtd file
	 */
	private final static String dtd = "<!-- DTD used by the java.util.logging.XMLFormatter -->\r\n"
			+ "<!-- This provides an XML formatted log message. -->\r\n\r\n"
			+ "<!-- The document type is \"log\" which consists of a sequence of record elements -->\r\n"
			+ "<!ELEMENT log (record*)>\r\n\r\n"
			+

			"<!-- Each logging call is described by a record element. -->\r\n"
			+ "<!ELEMENT record (date, millis, sequence, logger?, level, class?, method?, thread?, message, key?, catalog?, param*, exception?)>\r\n\r\n"
			+

			"<!-- Date and time when LogRecord was created in ISO 8601 format -->\r\n"
			+ "<!ELEMENT date (#PCDATA)>\r\n"
			+

			"<!-- Time when LogRecord was created in milliseconds since midnight January 1st, 1970, UTC. -->\r\n"
			+ "<!ELEMENT millis (#PCDATA)>\r\n"
			+

			"<!-- Unique sequence number within source VM. -->\r\n"
			+ "<!ELEMENT sequence (#PCDATA)>\r\n"
			+

			"<!-- Name of source Logger object. -->\r\n"
			+ "<!ELEMENT logger (#PCDATA)>\r\n\r\n"
			+

			"<!-- Logging level, may be either one of the constant names from java.util.logging.Constants (such as \"SEVERE\" or \"WARNING\") or an integer value such as \"20\". -->\r\n"
			+ "<!ELEMENT level (#PCDATA)>\r\n\r\n"
			+

			"<!-- Fully qualified name of class that issued logging call, e.g. \"javax.marsupial.Wombat\". -->\r\n"
			+ "<!ELEMENT class (#PCDATA)>\r\n\r\n"
			+

			"<!-- Name of method that issued logging call. It may be either an unqualified method name such as \"fred\" or it may include argument type information in parenthesis, for example \"fred(int,String)\". -->\r\n"
			+ "<!ELEMENT method (#PCDATA)>\r\n\r\n"
			+

			"<!-- Integer thread ID. -->\r\n"
			+ "<!ELEMENT thread (#PCDATA)>\r\n\r\n"
			+

			"<!-- The message element contains the text string of a log message. -->\r\n"
			+ "<!ELEMENT message (#PCDATA)>\r\n\r\n"
			+

			"<!-- If the message string was localized, the key element provides the original localization message key. -->\r\n"
			+ "<!ELEMENT key (#PCDATA)>\r\n\r\n"
			+

			"<!-- If the message string was localized, the catalog element provides the logger's localization resource bundle name. -->\r\n"
			+ "<!ELEMENT catalog (#PCDATA)>\r\n\r\n"
			+

			"<!-- If the message string was localized, each of the param elements provides the String value (obtained using Object.toString()) of the corresponding LogRecord parameter. -->"
			+ "<!ELEMENT param (#PCDATA)>\r\n\r\n"
			+

			"<!-- An exception consists of an optional message string followed by a series of StackFrames. Exception elements are used for Java exceptions and other java Throwables. -->\r\n"
			+ "<!ELEMENT exception (message?, frame+)>\r\n\r\n"
			+

			"<!-- A frame describes one line in a Throwable backtrace. -->\r\n"
			+ "<!ELEMENT frame (class, method, line?)>\r\n\r\n"
			+

			"<!-- an integer line number within a class's source file. -->"
			+ "<!ELEMENT line (#PCDATA)>";

	/**
	 * Returns the directory of the system logs.
	 * 
	 * @return returns the directory of the system logs
	 */
	private static String getLogDir() {
		return LOG_DIR + "/" + owner.getPeerType() + "/";
	}

	/**
	 * Log an exception, print out the stack track if in debugging mode
	 * 
	 * @param message
	 *            the error message
	 * @param e
	 *            the exception caught
	 */
	public static void LogException(String message, Exception e) {
		if (logger != null)
			logger.error(message);

		System.err.println(message);
		ShowGuiLog(new LogEvent(LogEventType.ERROR.getValue(), message, ""));

		// if (ServerPeer.DEBUG)
		e.printStackTrace();
	}

	/**
	 * Log an incoming message
	 * 
	 * @param pid
	 *            id (address) of the sender
	 * @param message
	 *            the message received
	 */
	public static void LogIncoming(String pid, Message message) {
		if (logger != null)
			logger.info("GET "
					+ MsgType.description(message.getHead().getMsgType()));

		ShowGuiLog(new LogEvent(LogEventType.INCOMINGMSG.getValue(), MsgType
				.description(message.getHead().getMsgType()), pid));

		try {
			if (dbconn == null || dbconn.isClosed())
				dbconn = getDBConnection();

			Statement stmt = dbconn.createStatement();
			String sql = "insert into LOG_MSG (head, body, size, sender) values (" //
					+ message.getHead().getMsgType()
					+ ", '" //
					+ message.getBody().toString().substring(
							0,
							Math
									.min(100, message.getBody().toString()
											.length())) + "', '" //
					+ message.getSize() + "', '" //
					+ pid //
					+ "')";
			stmt.execute(sql);
			stmt.close();
		} catch (Exception e) {
		}
	}

	/**
	 * Log an outgoing message
	 * 
	 * @param dest
	 *            destination of the message
	 * @param message
	 *            the message sent
	 */
	public static void LogOutgoing(String pid, Message message) {
		if (logger != null)
			logger.info("SEND " + message.toString());

		ShowGuiLog(new LogEvent(LogEventType.OUTGOINGMSG.getValue(), MsgType
				.description(message.getHead().getMsgType()), pid));

		try {
			if (dbconn == null || dbconn.isClosed())
				dbconn = getDBConnection();

			Statement stmt = dbconn.createStatement();
			String sql = "insert into LOG_MSG (head, body, size, receiver) values (" //
					+ message.getHead().getMsgType()
					+ ", '" //
					+ message.getBody().toString().substring(
							0,
							Math
									.min(100, message.getBody().toString()
											.length())) + "', '" //
					+ message.getSize() + "', '" //
					+ pid //
					+ "')";
			stmt.execute(sql);
			stmt.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Log an event for a successfully executed task
	 * 
	 * @param eventType
	 * @param message
	 * @param dest
	 */
	public static void LogPostEvent(String eventType, String message,
			String dest) {
		if (logger != null)
			logger.event(message);

		ShowGuiLog(new LogEvent(LogEventType.POST_EVENT.getValue(), message, ""));
	}

	/**
	 * Constructor
	 * 
	 * @param peer
	 *            the owner peer
	 */
	private LogManager(AbstractPeer peer) {
		owner = peer;

		logger = Logger.getLogger("sg.edu.nus");

		dbconn = getDBConnection();

		try {
			if (!logDirExists())
				createLogDir();

			handler = new FileHandler(getLogDir() + "log.%u.%g.xml");
			handler.setFormatter(new XMLFormatter());
			genDTD(); // create dtd
			logger.addHandler(handler);

			logger.setLogLevel(Level.INFO);

		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e2) {
			e2.printStackTrace();
		}
	}

	@SuppressWarnings("unused")
	private void closeConnection() {
		try {
			if (!dbconn.isClosed())
				dbconn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Create the directory for storing system logs. If the directory cannot be
	 * created, then exit system.
	 */
	private synchronized void createLogDir() {
		if (!logDirExists()) {
			File file = new File(getLogDir());
			if (!file.mkdirs()) {
				System.out.println("Cannot create the directory: "
						+ file.getAbsolutePath());
				System.exit(1);
			}
		}
	}

	/**
	 * Generate .dtd file for the log file if not exists
	 * 
	 * @throws IOException
	 */
	private void genDTD() throws IOException {
		File file = new File(getLogDir() + "logger.dtd");
		if (!file.exists()) {
			BufferedWriter writer = new BufferedWriter(new FileWriter(file));
			writer.write(dtd);
			writer.close();
		}
	}

	@SuppressWarnings("unused")
	private void clearLogDB() {
		try {
			Connection dbconn = AbstractPeer.bestpeer_db
					.createServerConnection();

			Statement stmt = dbconn.createStatement();

			String sql = "drop database " + LOG_DB;

			stmt.execute(sql);

			stmt.close();

			dbconn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * If <code>true</code>, the directory for storing system logs has already
	 * existed; otherwise return <code>false</code>.
	 * 
	 * @return returns <code>true</code> if the directory for storing system
	 *         logs has already existed; otherwise, return <code>false</code>
	 */
	private boolean logDirExists() {
		File file = new File(getLogDir());
		if (!file.exists())
			return false;
		else {
			if (!file.isDirectory())
				throw new RuntimeException(
						"Regular file with the same name exists: "
								+ file.getAbsolutePath());
			return true;
		}
	}
}
